<!DOCTYPE html>
<html lang="en">
<head>
	<link rel="stylesheet" href="./leaflet/dist/leaflet.css"/>
	<script src="./leaflet/dist/leaflet.js"></script>
	<script src="./leaflet/dist/leaflet.rotatedMarker.js"></script>
    <meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TCOM-500 ADSB Aircraft Tracker</title>
    <style>
        #map {
			position: absolute;
            top: 0;
			bottom: 0;
			left: 0;
			right: 0;
        }
    </style>
</head>
<body>
<div id="searchbox" style="position:absolute; top: 10px; right: 10px; z-index:1000; background:white; padding:6px;">
	<input id="icaoInput" placeholder="Search ICAO (hex)" maxlength="6" oninput="this.value=this.value.toUpperCase()">
    <button onclick="searchFlight()">Search</button>
</div>
<div id="buttons" style="position:absolute; top: 50px; right: 10px; z-index:999; background:white; padding:6px;">
    <button onclick="clearAllTracks()">Clear All Tracks</button>
</div>
<div id="map"></div>
<script>
    const map = L.map('map').setView([38.7513, -77.4707], 13);
    L.tileLayer('https://api.maptiler.com/maps/dataviz-v4/256/{z}/{x}/{y}.png?key=DD9SPIwXTwsF8LxESuIL', {
        maxZoom: 19,
        attribution: '© OpenStreetMap contributors'
    }).addTo(map);
	
/*
	Alternative map backdrop, too saturated with color and details
    L.tileLayer('https://api.maptiler.com/maps/base-v4/{z}/{x}/{y}.png?key=DD9SPIwXTwsF8LxESuIL', {
        maxZoom: 19,
        attribution: '© OpenStreetMap contributors'
    }).addTo(map);
*/

	const planeIconActive = L.icon({
		iconUrl: './leaflet/dist/images/PlaneIconActive.png',
		iconSize: [32, 32],
		iconAnchor: [16, 16],
	});

	const planeIconStale = L.icon({
		iconUrl: './leaflet/dist/images/PlaneIconStale.png',
		iconSize: [32, 32],
		iconAnchor: [16, 16],
	});

    let markers = {}; // hex → marker
	let tracks = {}; // hex → polyline
	let lastTrackFetch = {}; // hex → timestamp
	let lastUpdate = {}; // hex → timestamp (ms)

	async function refreshFlights() {
		try {
			const res = await fetch("http://localhost:8000/api/flights");
			const data = await res.json();
			const flights = data.flights || data;

			flights.forEach(f => {
				if (!f.lat || !f.lon) return;

				const key = f.hex;
				const lat = parseFloat(f.lat);
				const lon = parseFloat(f.lon);
				const heading = f.heading ? parseFloat(f.heading) : 0;

				if (!markers[key]) {
					markers[key] = L.marker([lat, lon], {
						icon: planeIconActive,
						rotationAngle: heading,
						rotationOrigin: 'center center'
					})
					.addTo(map)
					.bindPopup(`${key}<br>${f.callsign || ""}`)
					.on("click", () => {
						if (tracks[key]) {
							map.removeLayer(tracks[key]);
							delete tracks[key];
						} else {
							drawTrack(key);
						}
					});
				} else {
					markers[key].setLatLng([lat, lon]);
					markers[key].setRotationAngle(heading);
					markers[key].setPopupContent(`${key}<br>${f.callsign || ""}`);
				}

				// Update last seen time **only when position is valid**
				lastUpdate[key] = Date.now();
			});
		} catch (err) {
			console.error("Flight update failed:", err);
		}
	}

	async function searchFlight() {
		const hex = document.getElementById("icaoInput").value.trim();
		if (!hex) return;

		try {
			const res = await fetch(`http://localhost:8000/api/flights/${hex}`);
			const data = await res.json();

			if (!data.found) {
				alert("Flight not found");
				return;
			}

			const f = data.flight;
			if (!f.lat || !f.lon) {
				alert("Flight has no position yet");
				return;
			}

			const lat = parseFloat(f.lat);
			const lon = parseFloat(f.lon);

			// Zoom & center
			map.setView([lat, lon], 14, { animate: true });

			// Ensure marker exists
			if (markers[f.hex]) {
				markers[f.hex].openPopup();
				highlightMarker(markers[f.hex]);
			}

		} catch (err) {
			console.error("Search failed:", err);
		}
	}

	function highlightMarker(marker) {
		marker.setZIndexOffset(1000);
		setTimeout(() => marker.setZIndexOffset(0), 5000);
	}
	
	function clearTrack(hex) {
		if (tracks[hex]) {
			map.removeLayer(tracks[hex]);
			delete tracks[hex];
		}
	}

	function clearAllTracks() {
		Object.values(tracks).forEach(t => map.removeLayer(t));
		tracks = {};
	}

	async function drawTrack(hex) {
		try {
			const res = await fetch(`http://localhost:8000/api/track/${hex}`);
			const points = await res.json();

			const latlngs = points
				.filter(p => p.lat && p.lon)
				.map(p => [p.lat, p.lon]);

			if (latlngs.length === 0) return;

			if (!tracks[hex]) {
				tracks[hex] = L.polyline(latlngs, {
					color: 'gold',
					weight: 3
				}).addTo(map);
			} else {
				tracks[hex].setLatLngs(latlngs);
			}
		} catch (err) {
			console.error("Track update failed:", err);
		}
	}

	async function replayTrack(hex) {
		const res = await fetch(`/api/track/${hex}?limit=600`);
		const points = await res.json();

		let i = 0;
		const marker = markers[hex];

		const interval = setInterval(() => {
			if (i >= points.length) {
				clearInterval(interval);
				return;
			}

			marker.setLatLng([points[i].lat, points[i].lon]);
			marker.setRotationAngle(points[i].heading || 0);
			i++;
		}, 500); // replay speed
	}

    refreshFlights();           // initial load
    setInterval(refreshFlights, 2000);
	setInterval(() => {Object.keys(tracks).forEach(hex => {drawTrack(hex);});}, 2000);
	setInterval(() => {
		const now = Date.now();
		Object.keys(markers).forEach(key => {
			if (!lastUpdate[key]) return;

			const isStale = now - lastUpdate[key] > 20000; // 20 sec
			// Directly set the icon without equality check
			markers[key].setIcon(isStale ? planeIconStale : planeIconActive);
		});
	}, 1000);
	setInterval(() => {
		const now = Date.now();

		Object.keys(markers).forEach(key => {
			if (!lastUpdate[key]) return;

			const elapsed = now - lastUpdate[key];

			if (elapsed > 60 * 1000) { // 60 seconds
				// Remove marker
				map.removeLayer(markers[key]);
				delete markers[key];

				// Remove track if it exists
				if (tracks[key]) {
					map.removeLayer(tracks[key]);
					delete tracks[key];
				}

				// Remove lastUpdate entry
				delete lastUpdate[key];
			}
		});
	}, 1000); // check every second


    document.getElementById("icaoInput").addEventListener("keypress", e => {
        if (e.key === "Enter") {
            searchFlight();
        }
    });
	
</script>

</body>
</html>
